import pandas as pd
import numpy as np
import logging
from datetime import datetime, timedelta
from sklearn.preprocessing import StandardScaler, MinMaxScaler
import joblib
import os
from typing import Dict, List, Tuple, Optional
import warnings
warnings.filterwarnings('ignore')
from dotenv import load_dotenv
load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class CSVCovidDataPipeline:
    """
    üöÄ PIPELINE LONG TERME - VERSION 2.1
    
    NOUVEAUT√âS :
    - Pr√©dictions multi-temporelles : 6 mois, 1 an, 2 ans, 5 ans
    - D√©mographie = profil fixe exploit√© intelligemment
    - Vaccination = trigger progressif selon couverture r√©elle
    - Logique conditionnelle avant/apr√®s vaccination
    """
    
    def __init__(self, csv_data_path: str):
        self.csv_data_path = csv_data_path
        
        # Caches optimis√©s
        self.vaccination_cache = {}
        self.demographics_cache = {}
        self.country_population_cache = {}
        
        # üöÄ NOUVEAUX HORIZONS R√âVOLUTIONNAIRES
        self.prediction_horizons = [
            # Court terme (compatibilit√©)
            1, 7, 14, 30,
            # Moyen terme 
            90, 180,  # 3 mois, 6 mois
            # Long terme R√âVOLUTIONNAIRE
            365, 730, 1825  # 1 an, 2 ans, 5 ans
        ]
        
        # Mapping des fichiers CSV
        self.csv_files = {
            'covid_clean_complete': 'covid_19_clean_complete_clean.csv',
            'vaccination': 'cumulative-covid-vaccinations_clean.csv',
            'demographics': 'consolidated_demographics_data.csv'
        }
        
        logger.info("üöÄ Pipeline CSV R√âVOLUTIONNAIRE LONG TERME initialis√©")
        logger.info(f"üìÖ Horizons de pr√©diction : {self.prediction_horizons}")
    
    def load_vaccination_data(self) -> pd.DataFrame:
        """üíâ Charge donn√©es vaccination avec logique progressive"""
        logger.info("üíâ Chargement vaccination - Mode Progressif...")
        
        vax_file = os.path.join(self.csv_data_path, self.csv_files['vaccination'])
        
        if not os.path.exists(vax_file):
            logger.error(f"‚ùå Fichier vaccination introuvable: {vax_file}")
            return pd.DataFrame()
        
        vax_df = pd.read_csv(vax_file)
        vax_df.columns = vax_df.columns.str.strip()
        
        # Nettoyage
        vax_df['date'] = pd.to_datetime(vax_df['date'], errors='coerce')
        vax_df['cumulative_vaccinations'] = pd.to_numeric(vax_df['cumulative_vaccinations'], errors='coerce').fillna(0)
        vax_df['daily_vaccinations'] = pd.to_numeric(vax_df['daily_vaccinations'], errors='coerce').fillna(0)
        
        vax_df = vax_df.dropna(subset=['date'])
        vax_df = vax_df.sort_values(['country', 'date'])
        
        # üß† CALCULS INTELLIGENTS par pays
        for country in vax_df['country'].unique():
            if pd.notna(country):
                country_data = vax_df[vax_df['country'] == country].copy()
                
                # Population du pays (pour calculer la couverture r√©elle)
                population = self.get_country_population(country)
                
                # üìä Features vaccination INTELLIGENTES
                country_data['vaccination_coverage_real'] = (
                    country_data['cumulative_vaccinations'] / population * 100
                ).clip(0, 100)  # Max 100%
                
                # Impact progressif (pas tout d'un coup!)
                country_data['protection_factor'] = np.tanh(
                    country_data['vaccination_coverage_real'] / 30  # Saturation √† 30% de couverture
                )
                
                # Efficacit√© temporelle (baisse avec le temps)
                country_data['days_since_start'] = (
                    country_data['date'] - country_data['date'].min()
                ).dt.days
                
                country_data['vaccine_effectiveness'] = (
                    country_data['protection_factor'] * 
                    np.exp(-country_data['days_since_start'] / 365)  # Baisse chaque ann√©e
                )
                
                # Cache optimis√©
                self.vaccination_cache[country.strip().lower()] = country_data
        
        logger.info(f"üíâ {len(vax_df)} vaccinations trait√©es avec logique progressive")
        return vax_df
    
    def get_country_population(self, country: str) -> float:
        """üë• R√©cup√®re population pays depuis d√©mographie"""
        country_key = self.smart_country_matching(country)
        
        # Cache pour √©viter les recalculs
        if country_key in self.country_population_cache:
            return self.country_population_cache[country_key]
        
        # Valeur par d√©faut
        default_population = 50_000_000  # 50M par d√©faut
        
        # Chercher dans les donn√©es d√©mographiques
        demo_file = os.path.join(self.csv_data_path, self.csv_files['demographics'])
        if os.path.exists(demo_file):
            try:
                demo_df = pd.read_csv(demo_file)
                
                # Chercher le pays (plusieurs variantes possibles)
                country_matches = demo_df[
                    demo_df['Countries'].str.lower().str.contains(country_key, na=False)
                ]
                
                if len(country_matches) > 0:
                    # Prendre la donn√©e la plus r√©cente
                    latest = country_matches.sort_values('Year', ascending=False).iloc[0]
                    population = latest.get('Total population (thousands)', default_population / 1000) * 1000
                    self.country_population_cache[country_key] = population
                    return population
                    
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erreur lecture population {country}: {e}")
        
        self.country_population_cache[country_key] = default_population
        return default_population
    
    def load_demographics_data(self) -> pd.DataFrame:
        """üë• Charge d√©mographie comme PROFIL FIXE"""
        logger.info("üë• Chargement d√©mographie - Mode Profil Fixe...")
        
        demo_file = os.path.join(self.csv_data_path, self.csv_files['demographics'])
        
        if not os.path.exists(demo_file):
            logger.error(f"‚ùå Fichier d√©mographique introuvable")
            return pd.DataFrame()
        
        demo_df = pd.read_csv(demo_file)
        demo_df.columns = demo_df.columns.str.strip()
        
        # üß† EXPLOITATION INTELLIGENTE (pas de corr√©lation temporelle)
        for idx, row in demo_df.iterrows():
            country_name = row.get('Countries', '')
            if pd.notna(country_name) and country_name.strip():
                country_key = country_name.strip().lower()
                
                # üìä PROFIL D√âMOGRAPHIQUE FIXE
                profile = {
                    'population_millions': row.get('Total population (thousands)', 50000) / 1000,
                    'birth_rate': row.get('Birth rate', 15),
                    'mortality_rate': row.get('Mortality rate', 8),
                    'life_expectancy': row.get('Life expectancy', 70),
                    'infant_mortality_rate': row.get('Infant mortality rate', 25),
                    'fertility_rate': row.get('Number of children per woman', 2.5),
                    'growth_rate': row.get('Growth rate', 1.0),
                    'elderly_ratio': row.get('Share of people aged 65 and over (%)', 8) / 100,
                    
                    # üß† FACTEURS CALCUL√âS INTELLIGENTS
                    'covid_vulnerability': self.calculate_covid_vulnerability(row),
                    'demographic_resilience': self.calculate_demographic_resilience(row),
                    'age_mortality_factor': self.calculate_age_mortality_factor(row),
                }
                
                self.demographics_cache[country_key] = profile
        
        logger.info(f"üë• {len(self.demographics_cache)} profils d√©mographiques cr√©√©s")
        return demo_df
    
    def calculate_covid_vulnerability(self, demo_row) -> float:
        """üß† Calcule vuln√©rabilit√© COVID selon d√©mographie"""
        elderly_pct = demo_row.get('Share of people aged 65 and over (%)', 8)
        life_expectancy = demo_row.get('Life expectancy', 70)
        mortality_rate = demo_row.get('Mortality rate', 8)
        
        # Plus de personnes √¢g√©es = plus vuln√©rable
        # Moins d'esp√©rance de vie = plus vuln√©rable
        vulnerability = (
            (elderly_pct / 20) * 0.4 +  # 20% elderly = max factor
            (1 - life_expectancy / 85) * 0.3 +  # 85 ans = life expectancy max
            (mortality_rate / 15) * 0.3  # 15‚Ä∞ = mortality rate max
        )
        
        return np.clip(vulnerability, 0.1, 1.0)
    
    def calculate_demographic_resilience(self, demo_row) -> float:
        """üí™ Calcule r√©silience d√©mographique"""
        birth_rate = demo_row.get('Birth rate', 15)
        growth_rate = demo_row.get('Growth rate', 1.0)
        
        # Plus de naissances et croissance = plus r√©silient
        resilience = (
            (birth_rate / 40) * 0.6 +  # 40‚Ä∞ = birth rate max
            (growth_rate / 3) * 0.4  # 3% = growth rate max
        )
        
        return np.clip(resilience, 0.1, 1.0)
    
    def calculate_age_mortality_factor(self, demo_row) -> float:
        """‚ö∞Ô∏è Facteur mortalit√© selon √¢ge population"""
        elderly_pct = demo_row.get('Share of people aged 65 and over (%)', 8)
        infant_mortality = demo_row.get('Infant mortality rate', 25)
        
        # Plus de personnes √¢g√©es = mortalit√© COVID plus √©lev√©e
        # Mortalit√© infantile √©lev√©e = syst√®me sant√© faible
        age_factor = (
            (elderly_pct / 25) * 0.7 +  # 25% elderly = max
            (infant_mortality / 100) * 0.3  # 100‚Ä∞ = infant mortality max
        )
        
        return np.clip(age_factor, 0.1, 2.0)
    
    def get_vaccination_impact(self, country: str, target_date: datetime) -> Dict:
        """üíâ Impact vaccination INTELLIGENT selon date"""
        country_key = self.smart_country_matching(country)
        
        # Valeurs par d√©faut (pas de vaccination)
        impact = {
            'has_vaccination': False,
            'coverage_percent': 0.0,
            'protection_factor': 0.0,
            'case_reduction_factor': 1.0,  # 1.0 = pas de r√©duction
            'mortality_reduction_factor': 1.0,
            'days_since_vax_start': 0,
            'vaccination_momentum': 0.0
        }
        
        # Chercher donn√©es vaccination pour ce pays
        vaccination_data = None
        for cached_country, data in self.vaccination_cache.items():
            if country_key in cached_country or cached_country in country_key:
                vaccination_data = data
                break
        
        if vaccination_data is not None and len(vaccination_data) > 0:
            # Trouver la date la plus proche <= target_date
            valid_dates = vaccination_data[vaccination_data['date'] <= target_date]
            
            if len(valid_dates) > 0:
                latest_vax = valid_dates.sort_values('date').iloc[-1]
                
                coverage = latest_vax.get('vaccination_coverage_real', 0.0)
                protection = latest_vax.get('protection_factor', 0.0)
                effectiveness = latest_vax.get('vaccine_effectiveness', 0.0)
                
                if coverage > 0.1:  # Au moins 0.1% de couverture
                    impact.update({
                        'has_vaccination': True,
                        'coverage_percent': coverage,
                        'protection_factor': protection,
                        # üß† R√âDUCTIONS INTELLIGENTES
                        'case_reduction_factor': 1.0 - (effectiveness * 0.8),  # Max 80% r√©duction cas
                        'mortality_reduction_factor': 1.0 - (effectiveness * 0.95),  # Max 95% r√©duction d√©c√®s
                        'days_since_vax_start': latest_vax.get('days_since_start', 0),
                        'vaccination_momentum': latest_vax.get('daily_vaccinations', 0)
                    })
        
        return impact
    
    def smart_country_matching(self, country_name: str) -> str:
        """üéØ Matching intelligent noms pays"""
        normalized = country_name.strip().lower()
        
        # Mapping manuel √©tendu
        mapping = {
            'united states': 'us',
            'usa': 'us',
            'united kingdom': 'uk',
            'south korea': 'korea, south',
            'north korea': 'korea, north',
            'czech republic': 'czechia',
            'russia': 'russian federation',
            'iran': 'iran, islamic republic of',
            'venezuela': 'venezuela, bolivarian republic of',
            'syria': 'syrian arab republic',
            'tanzania': 'tanzania, united republic of',
            'bolivia': 'bolivia, plurinational state of',
            'vietnam': 'viet nam',
            'france': 'france',
            'germany': 'germany',
            'italy': 'italy',
            'spain': 'spain'
        }
        
        return mapping.get(normalized, normalized)
    
    def create_revolutionary_features(self, covid_df: pd.DataFrame) -> pd.DataFrame:
        """üß† Features r√©volutionnaires pour pr√©dictions long terme"""
        logger.info("üß† Cr√©ation features r√©volutionnaires LONG TERME...")
        
        enriched_rows = []
        
        for idx, row in covid_df.iterrows():
            country = row['country_name']
            date = row['date']
            
            # Features COVID de base
            base_features = row.to_dict()
            
            # üìÖ Features temporelles √©tendues
            temporal_features = {
                'day_of_year': date.timetuple().tm_yday,
                'month': date.month,
                'quarter': (date.month - 1) // 3 + 1,
                'week_of_year': date.isocalendar()[1],
                'month_sin': np.sin(2 * np.pi * date.month / 12),
                'month_cos': np.cos(2 * np.pi * date.month / 12),
                'weekday': date.weekday(),
                'is_weekend': 1 if date.weekday() >= 5 else 0,
                
                # üöÄ FEATURES LONG TERME
                'pandemic_year': (date - pd.to_datetime('2020-01-01')).days / 365.25,
                'pandemic_phase': min((date - pd.to_datetime('2020-01-01')).days / 730, 1.0),  # 2 ans max
                'seasonal_factor': np.cos(2 * np.pi * date.timetuple().tm_yday / 365.25),
            }
            
            # üë• PROFIL D√âMOGRAPHIQUE FIXE
            demographic_profile = self.get_demographic_profile(country)
            
            # üíâ IMPACT VACCINATION (selon la date!)
            vaccination_impact = self.get_vaccination_impact(country, date)
            
            # üß† FEATURES D'INTERACTION R√âVOLUTIONNAIRES
            interaction_features = {
                # Impact d√©mographique sur COVID
                'demographic_covid_severity': (
                    demographic_profile['covid_vulnerability'] * 
                    base_features['mortality_rate']
                ),
                
                # Capacit√© de r√©silience
                'country_resilience_score': (
                    demographic_profile['demographic_resilience'] * 
                    (1 - demographic_profile['covid_vulnerability'])
                ),
                
                # Impact vaccination modul√© par d√©mographie
                'vaccination_effectiveness_adjusted': (
                    vaccination_impact['protection_factor'] *
                    (2 - demographic_profile['covid_vulnerability'])  # Plus efficace si pop moins vuln√©rable
                ),
                
                # Mortalit√© pr√©dite selon √¢ge + vaccination
                'predicted_mortality_factor': (
                    demographic_profile['age_mortality_factor'] *
                    vaccination_impact['mortality_reduction_factor']
                ),
                
                # Phase √©pid√©mique
                'epidemic_phase': self.calculate_epidemic_phase(base_features, vaccination_impact),
            }
            
            # üöÄ FUSION TOTALE
            enriched_row = {
                **base_features,
                **temporal_features,
                **demographic_profile,
                **vaccination_impact,
                **interaction_features
            }
            
            enriched_rows.append(enriched_row)
        
        enriched_df = pd.DataFrame(enriched_rows)
        
        logger.info(f"üß† Dataset r√©volutionnaire cr√©√©: {len(enriched_df)} lignes √ó {len(enriched_df.columns)} features")
        return enriched_df
    
    def get_demographic_profile(self, country: str) -> Dict:
        """üë• R√©cup√®re profil d√©mographique du cache"""
        country_key = self.smart_country_matching(country)
        
        # Chercher dans le cache
        for cached_country, profile in self.demographics_cache.items():
            if country_key in cached_country or cached_country in country_key:
                return profile
        
        # Profil par d√©faut si pas trouv√©
        return {
            'population_millions': 50,
            'birth_rate': 15,
            'mortality_rate': 8,
            'life_expectancy': 70,
            'infant_mortality_rate': 25,
            'fertility_rate': 2.5,
            'growth_rate': 1.0,
            'elderly_ratio': 0.08,
            'covid_vulnerability': 0.5,
            'demographic_resilience': 0.5,
            'age_mortality_factor': 1.0,
        }
    
    def calculate_epidemic_phase(self, covid_data: Dict, vaccination_impact: Dict) -> float:
        """üìä Calcule phase √©pid√©mique (croissance/d√©croissance/plateau)"""
        growth_rate = covid_data.get('growth_rate', 0)
        has_vaccination = vaccination_impact.get('has_vaccination', False)
        protection = vaccination_impact.get('protection_factor', 0)
        
        if not has_vaccination:
            # Phase pr√©-vaccination : croissance naturelle
            if growth_rate > 0.05:  # Croissance forte
                return 1.0  # Phase ascendante
            elif growth_rate > -0.05:  # Plateau
                return 0.5  # Phase plateau
            else:
                return 0.0  # Phase descendante naturelle
        else:
            # Phase vaccination : d√©croissance esp√©r√©e
            expected_decline = -protection * 0.1  # Plus de protection = plus de d√©clin
            if growth_rate > expected_decline + 0.05:
                return 0.8  # R√©sistance √† la vaccination
            elif growth_rate > expected_decline - 0.05:
                return 0.3  # D√©clin selon attentes
            else:
                return 0.1  # D√©clin rapide
    
    def run_full_pipeline(self) -> pd.DataFrame:
        """üöÄ Pipeline complet R√âVOLUTIONNAIRE LONG TERME"""
        logger.info("üöÄ D√âMARRAGE PIPELINE R√âVOLUTIONNAIRE LONG TERME")
        
        # 1. Charger donn√©es d√©mographiques (profils fixes)
        demographics_df = self.load_demographics_data()
        
        # 2. Charger donn√©es vaccination (impact progressif)
        vaccination_df = self.load_vaccination_data()
        
        # 3. Charger s√©ries temporelles COVID
        covid_df = self.load_covid_timeseries_from_csv()
        
        # 4. Cr√©er dataset r√©volutionnaire
        enriched_dataset = self.create_revolutionary_features(covid_df)
        
        # 5. Sauvegarde
        output_file = os.path.join(self.csv_data_path, 'enriched_covid_dataset_longterm.csv')
        enriched_dataset.to_csv(output_file, index=False)
        logger.info(f"üíæ Dataset r√©volutionnaire sauvegard√©: {output_file}")
        
        logger.info("üéâ PIPELINE R√âVOLUTIONNAIRE LONG TERME TERMIN√â!")
        return enriched_dataset
    
    def load_covid_timeseries_from_csv(self) -> pd.DataFrame:
        """ü¶† Charge s√©ries temporelles COVID (m√©thode existante)"""
        logger.info("ü¶† Chargement s√©ries temporelles COVID...")
        
        covid_file = os.path.join(self.csv_data_path, self.csv_files['covid_clean_complete'])
        
        if not os.path.exists(covid_file):
            covid_file = os.path.join(self.csv_data_path, 'full_grouped_clean.csv')
            if not os.path.exists(covid_file):
                raise ValueError("‚ùå Aucun fichier COVID trouv√©!")
        
        covid_df = pd.read_csv(covid_file)
        covid_df.columns = covid_df.columns.str.strip()
        
        # Normalisation colonnes
        column_mapping = {
            'Country/Region': 'country_name',
            'Country_Region': 'country_name',
            'Country': 'country_name',
            'Date': 'date',
            'Confirmed': 'confirmed',
            'Deaths': 'deaths', 
            'Recovered': 'recovered',
            'Active': 'active'
        }
        
        for old_col, new_col in column_mapping.items():
            if old_col in covid_df.columns:
                covid_df = covid_df.rename(columns={old_col: new_col})
        
        # Nettoyage
        covid_df['date'] = pd.to_datetime(covid_df['date'], errors='coerce')
        covid_df['confirmed'] = pd.to_numeric(covid_df['confirmed'], errors='coerce').fillna(0)
        covid_df['deaths'] = pd.to_numeric(covid_df['deaths'], errors='coerce').fillna(0)
        covid_df['recovered'] = pd.to_numeric(covid_df['recovered'], errors='coerce').fillna(0)
        
        if 'active' not in covid_df.columns:
            covid_df['active'] = covid_df['confirmed'] - covid_df['deaths'] - covid_df['recovered']
        else:
            covid_df['active'] = pd.to_numeric(covid_df['active'], errors='coerce').fillna(0)
        
        covid_df = covid_df.dropna(subset=['date'])
        covid_df = covid_df[covid_df['country_name'].notna()]
        covid_df = covid_df.sort_values(['country_name', 'date'])
        
        # Features COVID √©tendues
        covid_df['new_cases'] = covid_df.groupby('country_name')['confirmed'].transform(
            lambda x: x.diff().fillna(0).clip(lower=0)
        )
        covid_df['new_deaths'] = covid_df.groupby('country_name')['deaths'].transform(
            lambda x: x.diff().fillna(0).clip(lower=0)
        )
        covid_df['new_recovered'] = covid_df.groupby('country_name')['recovered'].transform(
            lambda x: x.diff().fillna(0).clip(lower=0)
        )
        
        covid_df['new_cases_ma7'] = covid_df.groupby('country_name')['new_cases'].transform(
            lambda x: x.rolling(window=7, min_periods=1).mean()
        )
        covid_df['new_deaths_ma7'] = covid_df.groupby('country_name')['new_deaths'].transform(
            lambda x: x.rolling(window=7, min_periods=1).mean()
        )
        
        covid_df['growth_rate'] = covid_df.groupby('country_name')['confirmed'].transform(
            lambda x: x.pct_change().fillna(0)
        )
        covid_df['mortality_rate'] = (covid_df['deaths'] / covid_df['confirmed'].clip(lower=1) * 100).fillna(0)
        covid_df['recovery_rate'] = (covid_df['recovered'] / covid_df['confirmed'].clip(lower=1) * 100).fillna(0)
        
        covid_df['trend_7d'] = covid_df.groupby('country_name')['new_cases_ma7'].transform(
            lambda x: x.diff().apply(lambda v: 1 if v > 0 else (-1 if v < 0 else 0))
        )
        
        logger.info(f"ü¶† {len(covid_df)} points COVID charg√©s")
        return covid_df

if __name__ == "__main__":
    CSV_DATA_PATH = '../data/dataset_clean'
    
    pipeline = CSVCovidDataPipeline(CSV_DATA_PATH)
    enriched_data = pipeline.run_full_pipeline()
    
    print("\nüéØ STATISTIQUES R√âVOLUTIONNAIRES LONG TERME:")
    print(f"üìä Lignes: {len(enriched_data):,}")
    print(f"üìà Features: {len(enriched_data.columns)}")
    print(f"üè≥Ô∏è Pays: {enriched_data['country_name'].nunique()}")
    print(f"üìÖ P√©riode: {enriched_data['date'].min()} ‚Üí {enriched_data['date'].max()}")
    print(f"üöÄ Pr√™t pour pr√©dictions LONG TERME!")